---
title: "React Router V6 - Loading Data"
excerpt: "上一篇介紹了 React Router V6 的基本架構，包含導頁、動態路由與巢狀路由，本文則會介紹 V6 全新的重要功能 Loader，來體驗一下它的威力吧！"
tags: ["React", "React Router"]
date: "2023-03-31"
---

## What's New in React Router v6

「進入畫面後，需要 Call API 取得初始資料！」

這個需求應該不陌生吧？許多頁面都有這個動作，例如：一進到商品頁，先取得商品資料。

這麼做並沒錯，但是這在使用者體驗上較差，因爲當 User 進入頁面時，畫面或許還沒渲染完成。

針對這一點，React Router V6 提供了 `loader` 這項功能，讓資料可以透過路由系統先行處理，在渲染前先 Loading Data。

## 使用 loader 與 useLoaderData 獲取資料

可以為路由定義 `loader` 參數，值為一個函式，並且預期會 Return 資料，讓我們在元件中取用。

我們在 `loader` 使用 Async/Await 去呼叫 API，雖然這會回傳一個 Promise，但是 React Router 會確保 API 資料已經回傳，讓我們能夠在元件中取得 `resData.events` 的資料。

```jsx
// App.js

const router = createBrowserRouter([
  {
    path: "/",
    element: <RootLayout />,
    children: [
      {
        path: "events",
        element: <EventRootLayout />,
        children: [
          {
            index: true,
            element: <Events />,
            loader: async () => {
              const response = await fetch("http://localhost:8080/events");
              if (!response.ok) {
                // Handle Error...
              } else {
                const resData = await response.json();
                return resData.events;
              }
            },
          },
        ],
      },
    ],
  },
]);
```

然後我們就可以很輕鬆自在地，直接到元件裡面，透過 `useLoaderData` 取得 Events 資料。

```jsx
// Events.js

const EventsPage = () => {
  const events = useLoaderData();

  return <EventsList events={events} />;
};

export default EventsPage;
```

嗯 ⋯⋯ 但是如果我們在 `App.js` 這類定義路由的檔案寫一堆 `loader`，那這個檔案不就會變得超大一包嗎？

沒錯喔，所以建議的做法還是將 Loader 寫在 Page Component 裡面再 `export` 到路由裡面定義。

```jsx
// Events.js

// ...
export default EventsPage;

export const loader = async () => {
  const response = await fetch("http://localhost:8080/events");
  if (!response.ok) {
    // Handle Error...
  } else {
    const resData = await response.json();
    return resData.events;
  }
};
```

在路由中 `import` 定義的 `loader` 時，可以用 alias 定義不同 Page 的 `loader` 名稱，例如 `Events` 就是 `eventsLoader`。

```jsx
// App.js

import Events, { loader as eventsLoader } from "./pages/Events";

const router = createBrowserRouter([
  {
    path: "/",
    element: <RootLayout />,
    children: [
      ,
      {
        path: "events",
        element: <EventRootLayout />,
        children: [
          {
            index: true,
            element: <Events />,
            loader: eventsLoader,
          },
        ],
      },
    ],
  },
]);
```

## Behind The Scenes: When Are loader() Functions Executed

如果你的 API 回傳時間較長，或是刻意讓 API 延遲回傳，就可以發現 Router 的跳轉，其實是等到 `loader` 取得資料後才執行。

這個機制的優點是能夠確保你已經取得資料，接著才去渲染畫面。但缺點是，使用者在切換路由時可能會出現延遲，搞不好還會因此以為網頁壞掉了。

關於這個問題，我們可以透過 `useNavigation` 的 `state` 去判斷該路由的狀態，並根據狀態加上 Loading 樣式。

```jsx
const RootLayout = () => {
  const navigation = useNavigation();

  return (
    <>
      <MainNavigation />
      <main>
        {navigation.state === "loading" && <p>Loading...</p>}
        <Outlet />
      </main>
    </>
  );
};
```

提醒一下，`loader()` 是在 Browser 環境執行，而非在 Server 執行。

另外，雖然是在 Browser 執行，但是 `loader()` 裡面「不能」使用像是 `useState` 與 `useParams` 等 React Hooks。

## Throw Responses and Catch Errors with useRouteError

在上一篇 React Router Setup 的文章裡，我們使用 `errorElement` 來指定當路由導向發生錯誤時，應該渲染的頁面或元件。而這個 Error 頁面除了用在處理錯誤的路由，同樣也能用來處理錯誤的 API 回應。

範例：首先，在父路由（也就是最外層）設置錯誤頁面。

```jsx
const router = createBrowserRouter([
  {
    path: "/",
    element: <RootLayout />,
    errorElement: <Error />, // catch any errors
    children: [
      { index: true, element: <Home /> },
      {
        path: "events",
        element: <EventRootLayout />,
        children: [
          {
            index: true,
            element: <Events />,
            loader: eventsLoader,
          },
        ],
      },
    ],
  },
]);
```

> 根據需求，你可以在父子路由個別設置 `errorElement`，但如果子路由沒有設置，那麼子路由的 Error 就會 Bubble Up 至父路由。

接下來我們用 `throw new Response()` 的方式拋出錯誤，這是一個近期比較推薦的做法，因為這樣可以讓前端依照不同的 `status` 顯示不同資訊給使用者。

```jsx
// Events.js

const EventsPage = () => {
  const data = useLoaderData();
  const events = data.events;

  return <EventsList events={events} />;
};

export default EventsPage;

export const loader = async () => {
  const response = await fetch("http://localhost:8080/events");
  if (!response.ok) {
    throw new Response(JSON.stringify({ message: "Could not fetch events" }), {
      status: 500,
    });
  } else {
    return response;
  }
};
```

定義好錯誤訊息後，我們透過 React Router V6 提供的 `useRouteError` 去取得錯誤訊息。

當我們是 Throw Responses 的時候，`useRouteError` 能透過 `JSON.parse(error.data)` 去取得回傳資料，以及透過 `error.status` 取得不同的狀態。

```jsx
// Error.js

const Error = () => {
  const error = useRouteError();

  let title = "Oops!";
  let message = "Sorry, an unexpected error has occurred.";

  // API Error
  if (error.status === 500) {
    message = JSON.parse(error.data).message;
  }

  // Path Error
  if (error.status === 404) {
    title = "Not Found!";
    message = "Could not find resource or page.";
  }

  return (
    <PageContent title={title}>
      <p>{message}</p>
    </PageContent>
  );
};
```

> 如果你是回傳一般物件，像是 `return {message: "error"}`，那麼這個 `error` 就會是那個物件本身了。

## The Utility Function: json()

我必須承認，我自己看到回傳 Responses 的作法時覺得很麻煩，雖然遵循這個方式可以定義不同的錯誤狀態，以給予更好的使用者體驗，但是這讓 Code 變得複雜許多啊！

還好！或許是因為 React Router V6 團隊也覺得很繁瑣，所以他們準備了一個 Utility Function 叫做 `json()` 讓我們使用 🥺

總之，你剛剛上面那一大串，可以變成以下這樣。

```jsx
// Events.js

export const loader = async () => {
  const response = await fetch("http://localhost:8080/events22");
  if (!response.ok) {
    // throw new Response(JSON.stringify({ message: "Could not fetch events" }), {
    //   status: 500,
    // });
    throw json({ message: "Could not fetch events" }, { status: 500 });
  } else {
    return response;
  }
};
```

與此同時，你用 `useRouteError` 取得 `error.data` 後也不需要再做 `JSON.parse()` 了。

```jsx
// Error.js

if (error.status === 500) {
  // message = JSON.parse(error.data).message;
  message = error.data.message;
}
```

可喜可賀 🍻

## 使用 loader() 的參數

`loader` 自帶兩個參數 `request` 與 `params`：

- `request` 為一個 Request 的 Standard Web Object，可以存取像是 URL 等資訊
- `params` 為 Route Parameters，也就是動態路由冒號後面的 Segments

例如：位於 `/events/:eventId` 頁面時，`loader()` 可以透過 `params.eventId` 取得動態路由的片段，進而取得活動的詳細資料。

```jsx
// EventDetail.js

export const loader = async ({ request, params }) => {
  const id = params.eventId;
  const response = await fetch(`http://localhost:8080/events/${id}`);
  if (!response.ok) {
    throw json(
      { message: "Could not fetch details for the selected event" },
      {
        status: 500,
      },
    );
  } else {
    return response;
  }
};
```

## 通過 useRouteLoaderData() 在子路由之間分享 loader

如果當前的路由需要的 Loader 已經在其他路由定義過，我們就不用重複撰寫一次，可以經由 useRouteLoaderData Hook 來存取這份 Loader。

路由之間想要分享同一份 Loader 時必須是子路由，我們可以新增一層父路由，不給予 `element` 而是只定義 `loader`，同時賦予一個 `id`，這樣裡面的子路由就能透過 `useRouteLoaderData(id)` 取得資料。

範例：當 EditEvent 頁面也需要使用 EventDetail 頁面的 Loader 時，首先重新配置路由，將它們放在同一個父路由底下。

```jsx
// App.js

const router = createBrowserRouter([
  {
    path: "/",
    children: [
      {
        path: "events",
        element: <EventRootLayout />,
        children: [
          {
            path: ":eventId",
            id: "event-detail", // 記得加上 ID
            loader: eventDetailLoader, // 共用的 Loader
            children: [
              {
                index: true,
                element: <EventDetail />,
              },
              { path: "edit", element: <EditEvent /> },
            ],
          },
        ],
      },
    ],
  },
]);
```

在 EventDetail 頁面中，原本的 `useLoaderData` 改為使用 `useRouteLoaderData`。而 EditEvent 頁面也使用 `useRouteLoaderData("event-detail")` 取得 Loader 資料。

```jsx
// EventDetail.js
const EventDetail = () => {
  const data = useRouteLoaderData("event-detail");

  return <EventItem event={data.event} />;
};

// EditEvent.js
const EditEvent = () => {
  const data = useRouteLoaderData("event-detail");

  return (
    <>
      <h1>EditEvent</h1>
      <EventForm event={data.event} />
    </>
  );
};
```

> 注意：`useRouteLoaderData` 必須接收 Routes ID 這一個參數才能運作喔。
